<?php 

namespace Lalamove\Logger;

use App\TestCase;
use Lalamove\Logger\Logger;
use Lalamove\Logger\CustomHandler;
use Lalamove\Logger\HumanReadableFormatter;

use Mockery;
use Monolog\Formatter\JsonFormatter;
use PHPUnit_Framework_TestCase;

class ExceptionMock
{
    protected $message;

    public function __construct($msg)
    {
        $this->message = $msg;
    }

    public function getMessage()
    {
        return $this->message;
    }

    public function getTraceAsString()
    {
        return "";
    }
}

/**
 * LoggerTest class
 *
 * @group unitTest
 */
class LoggerTest extends PHPUnit_Framework_TestCase
{
    public function setUp()
    {
        $uuid = "DUMMYUUID";
        if (!defined('FOOTPRINT')) {
            define('FOOTPRINT', $uuid);
        }
        $this->footprint = FOOTPRINT;
        parent::setUp();
    }

    public function tearDown()
    {
        Mockery::close();
        parent::tearDown();
    }

    /**
     * testLogConstructor function
     * it tests if the constructor of the logger behaves the way we expect
     * when passing different parameters
     */
    public function testLogConstructor()
    {
        // assumes we are in ldev
        // see Logger.php
        $handler = new CustomHandler(
            "php://stdout",
            [
                Logger::INFO,
                Logger::CRITICAL,
                Logger::ERROR,
                Logger::WARNING,
                Logger::FATAL,
                Logger::DEBUG,
            ]
        );
        $formatter = new HumanReadableFormatter();
        $handler->setFormatter($formatter);
        $LoggerLDEV = new Logger(
            "appLogger",
            [
                "level",
                "message",
                "src_file",
                "src_line",
                "context",
                "time",
                "backtrace",
            ],
            [$handler]
        );

        $handler = $LoggerLDEV->getHandlers()[0];
        $this->assertEquals(($handler instanceof CustomHandler), true);
        $formatter = $handler->getFormatter();
        $this->assertEquals(($formatter instanceof HumanReadableFormatter), true);
    }

    /**
     * testAutoAddingFootprint function
     * tests if adding the logger adds the footprint automatically if not explicitely
     * added in the context
     */
    public function testAutoAddingFootprint()
    {
        $mock = \Mockery::mock('Lalamove\Logger\CustomHandler[handle]', [
            "php://stdout",
            [
                Logger::INFO,
                Logger::CRITICAL,
                Logger::ERROR,
                Logger::WARNING,
                Logger::FATAL,
                Logger::DEBUG,
            ]
        ]);
        
        $uuid;
        if (!defined('FOOTPRINT')) {
            $uuid = "DUMMYUUID";
            define('FOOTPRINT', $uuid);
        } else {
            $uuid = FOOTPRINT;
        }
        // 'message'=>'testfoorprint','src_file'=>'/application/appNew/Utils/Logger/LoggerTest.php','src_line'=>113,'level'=>'DEBUG'
        $arg1 = [
            'message' =>"test foor print",
            'src_file' =>"testFile",
            'src_line' =>"15",
            'level' =>"DEBUG",
            'time' =>"test",
            'context' => [
              'foo' => "bar",
              'timestamp' => "test",
              'footprint' => FOOTPRINT,
            ]
        ];

        $mock->shouldReceive("handle")
        ->once()
        ->withArgs([$arg1])
        ->andReturn(true);

        $formatter = new HumanReadableFormatter();
        $mock->setFormatter($formatter);
        $Logger = new Logger(
            "appLogger",
            [
                "level",
                "message",
                "src_file",
                "src_line",
                "context",
                "time",
                "backtrace",
            ],
            [$mock]
        );
       
        $Logger->debug(
            "test foor print",
            [
                "foo" => "bar",
                "timestamp" => "test",
                "src_line" => "15",
                "src_file" => "testFile",
            ]
        );
    }

    /**
     * testHumanReadableFormat function
     * It tests the output generated by the humanreadableformatter
     */
    public function testHumanReadableFormat()
    {
        $humanReadableFormatter = new HumanReadableFormatter();
        $dummyRecords = [
            [
                "record" => [
                    "level" => "UNKNOWNLEVEL", // TO AVOID COLORS
                    "message" => "Test message",
                    "time" => "dummy time"
                ],
                "output" => "\ndummy time | UNKNOWNLEVEL | Test message\n  level : UNKNOWNLEVEL\n  message : Test message\n  time : dummy time\n",
            ],
            [
                "record" => [
                    "level" => "INFO", // TO AVOID COLORS
                    "message" => "Test message",
                    "time" => "dummy time"
                ],
                "output" => "\033[0;32m\ndummy time | INFO | Test message\n  level : INFO\n  message : Test message\n  time : dummy time\n\033[0m",
            ],
            [
                "record" => [
                    "level" => "ERROR", // TO AVOID COLORS
                    "message" => "Test message",
                    "time" => "dummy time"
                ],
                "output" => "\033[0;31m\ndummy time | ERROR | Test message\n  level : ERROR\n  message : Test message\n  time : dummy time\n\033[0m",
            ]
        ];

        foreach ($dummyRecords as $rec) {
            $formattedOutput = $humanReadableFormatter->format($rec["record"]);
            $this->assertEquals($formattedOutput, $rec["output"]);
        }
    }


    /**
     * testHumanReadableFormat function
     * It tests the output generated by the humanreadableformatter
     */
    public function testAddsBacktraceIfException()
    {
        $mock = \Mockery::mock('Lalamove\Logger\CustomHandler[handle]', [
            "php://stdout",
            [
                Logger::INFO,
                Logger::CRITICAL,
                Logger::ERROR,
                Logger::WARNING,
                Logger::FATAL,
                Logger::DEBUG,
            ]
        ]);
        $formatter = new HumanReadableFormatter();
        $mock->setFormatter($formatter);
        $Logger = new Logger(
            "appLogger",
            [
                "level",
                "message",
                "src_file",
                "src_line",
                "context",
                "time",
                "backtrace",
            ],
            [$mock]
        );

        $e = Mockery::mock('Lalamove\Logger\ExceptionMock[getTraceAsString,getMessage]', ["testException"]);
        $e->shouldReceive("getTraceAsString")
        ->once()
        ->withAnyArgs()
        ->andReturn("foobar backtrace");

        $e->shouldReceive("getMessage")
        ->once()
        ->withAnyArgs()
        ->andReturn("testException");

        $arg1 = [
            "message" => "testException",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "INFO",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
            "backtrace" => "foobar backtrace",
        ];


        $mock->shouldReceive("handle")
        ->once()
        ->withArgs([$arg1])
        ->andReturn(true);

        $Logger->info($e, [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }

    /**
     * prepareLoggerFunc function
     * generic function to run tests on different logging functions
     *
     * @param array $arg
     */
    protected function prepareLoggerFunc($arg)
    {
        $mock = \Mockery::mock('Lalamove\Logger\CustomHandler[handle]', [
            "php://stdout",
            [
                Logger::INFO,
                Logger::CRITICAL,
                Logger::ERROR,
                Logger::WARNING,
                Logger::FATAL,
                Logger::DEBUG,
            ]
        ]);
        $formatter = new HumanReadableFormatter();
        $mock->setFormatter($formatter);
        $mock->shouldReceive("handle")
        ->once()
        ->withArgs([$arg])
        ->andReturn(true);
        $logger = new Logger(
            "appLogger",
            [
                "level",
                "message",
                "src_file",
                "src_line",
                "context",
                "time",
                "backtrace",
            ],
            [$mock]
        );
        return $logger;
    }

    public function testLogInfo()
    {
        $arg1 = [
            "message" => "testMessage",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "INFO",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
        ];
        $logger = $this->prepareLoggerFunc($arg1);
        $logger->info("testMessage", [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }

    public function testLogError()
    {
        $arg1 = [
            "message" => "testMessage",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "ERROR",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
        ];
        $logger = $this->prepareLoggerFunc($arg1);
        $logger->error("testMessage", [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }

    public function testLogWarning()
    {
        $arg1 = [
            "message" => "testMessage",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "WARNING",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
        ];
        $logger = $this->prepareLoggerFunc($arg1);
        $logger->warning("testMessage", [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }

    public function testLogFatal()
    {
        $arg1 = [
            "message" => "testMessage",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "FATAL",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
        ];
        $logger = $this->prepareLoggerFunc($arg1);
        $logger->fatal("testMessage", [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }

    public function testLogDebug()
    {
        $arg1 = [
            "message" => "testMessage",
            "src_file" => "testFile",
            "src_line" => "15",
            "level" => "DEBUG",
            "time" => "test",
            "context" => [
              "foo" => "bar",
              "timestamp" => "test",
              "footprint" => $this->footprint,
            ],
        ];
        $logger = $this->prepareLoggerFunc($arg1);
        $logger->debug("testMessage", [
            "foo" => "bar",
            "timestamp" => "test",
            "src_line" => "15",
            "src_file" => "testFile",
        ]);
    }


    public function testLogBatchFormat()
    {
        $formatter = new HumanReadableFormatter();
        $records = [
            [
                "message" => "testMessage",
                "src_file" => "testFile",
                "src_line" => "15",
                "level" => "NONDEFINEDCOLOR",
                "time" => "test",
                "context" => [
                  "foo" => "bar",
                  "timestamp" => "test",
                  "footprint" => $this->footprint,
                ],
            ],
            [
                "message" => "testMessage",
                "src_file" => "testFile",
                "src_line" => "15",
                "level" => "NONDEFINEDCOLOR",
                "time" => "test",
                "context" => [
                  "foo" => "bar",
                  "timestamp" => "test",
                  "footprint" => $this->footprint,
                ],
            ],
        ];
        $str = $formatter->formatBatch($records);
        $expectedStr =
            "\n\ntest | NONDEFINEDCOLOR | testMessage\n".
            "  message : testMessage\n".
            "  src_file : testFile\n".
            "  src_line : 15\n".
            "  level : NONDEFINEDCOLOR\n".
            "  time : test\n".
            "  context :\n".
            "    foo : bar\n".
            "    timestamp : test\n".
            "    footprint : $this->footprint\n\n\n".
            "\ntest | NONDEFINEDCOLOR | testMessage\n".
            "  message : testMessage\n".
            "  src_file : testFile\n".
            "  src_line : 15\n".
            "  level : NONDEFINEDCOLOR\n".
            "  time : test\n".
            "  context :\n".
            "    foo : bar\n".
            "    timestamp : test\n".
            "    footprint : $this->footprint\n\n";
        $this->assertEquals($str, $expectedStr);
    }
}
